

@import org.openmole.site.stylesheet._
@import org.openmole.site._
@import org.openmole.site.tools._
@import DocumentationPages._



@h2{"Aggregating Results of a Direct Sampling"}

@h3{"In Arrays"}

Direct sampling and offers a way to aggregate the multiple output value of the model generated by the multiple execution of the model. This is done by settings the argument aggregation of the @code{"Direct Sampling"} or @code{"Replication"} method.

The simplest usage is to generate an array of all the computed outputs. You can then store it using a hook or pass it to a subsequent task:


@hl.openmole(s"""
   val input_i = Val[Int]
   val input_j = Val[Double]
   val output1 = Val[Double]
   val output2 = Val[Double]

   val postProcessingTask =
     ScalaTask($tq
       // my post processing code
     $tq) set (
       inputs += (output1.array, output2.array)
     )

   DirectSampling(
     evaluation = my_own_model,
     sampling =
       (input_i in (0 to 10 by 2)) x
       (input_j in (0.0 to 5.0 by 0.5)),
     aggregation = Seq(output1, output2)
   ) -- postProcessingTask
""", header = "val my_own_model = EmptyTask()", name = "aggregate array")

@h3{"Statistic Indicators"}

OpenMOLE provides a bunch on statistic function you can use to aggregate you outputs. The list of these function is @a("available in the doc", href := scalaFunction.file).

You can use these function either in a @code{"ScalaTask"} to post process your results or using the @code("evaluate") keyword:
@hl.openmole(s"""
   val input_i = Val[Int]
   val input_j = Val[Double]
   val output1 = Val[Double]
   val output2 = Val[Double]

   DirectSampling(
     evaluation = my_own_model,
     sampling =
       (input_i in (0 to 10 by 2)) x
       (input_j in (0.0 to 5.0 by 0.5)),
     aggregation = Seq(
       output1 evaluate median,
       output2 evaluate average
     )
   )
""", header = "val my_own_model = EmptyTask()", name = "aggregate statistics")

@h3{"You own function"}

You can also provide your own scala function to aggregate the data, as it is shown in the following example:

@hl.openmole(s"""
   val input_i = Val[Int]
   val input_j = Val[Double]
   val output1 = Val[Double]
   val output2 = Val[Double]

   DirectSampling(
     evaluation = my_own_model,
     sampling =
       (input_i in (0 to 10 by 2)) x
       (input_j in (0.0 to 5.0 by 0.5)),
     aggregation = Seq(
       output1 evaluate "output1.sum / 3.0",
       output2 evaluate "output2.sum / 3.0"
     )
   )
""", header = "val my_own_model = EmptyTask()", name = "my aggregate text function")

Or:

@hl.openmole(s"""
   val input_i = Val[Int]
   val input_j = Val[Double]
   val output1 = Val[Double]
   val output2 = Val[Double]

   def myAggregation(d: Array[Double]) = d.sum / 3.0

   DirectSampling(
     evaluation = my_own_model,
     sampling =
       (input_i in (0 to 10 by 2)) x
       (input_j in (0.0 to 5.0 by 0.5)),
     aggregation = Seq(
       output1 evaluate myAggregation,
       output2 evaluate myAggregation
     )
   )
""", header = "val my_own_model = EmptyTask()", name = "my aggregate function")


